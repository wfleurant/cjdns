#!/usr/bin/env node
/* -*- Mode:Js */
/* vim: set expandtab ts=4 sw=4: */
/*
 * You may redistribute this program and/or modify it under the terms of
 * the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
var Cjdns  = require('../contrib/nodejs/cjdnsadmin/cjdnsadmin');
var http   = require('http');
var Crypto = require('crypto');

var numForAscii = [
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,
    99,99,99,99, 0,1,2,3,4,5,6,7,8,9,99,99,99,99,99,99,99,99,10,11,12,
    99,13,14,15,99,16,17,18,19,20,99,21,22,23,24,25,26,27,28,29,30,31,
    99,99,99,99,99,99,99,10,11,12,99,13,14,15,99,16,17,18,19,20,99,21,
    22,23,24,25,26,27,28,29,30,31,99,99,99,99,99,
];
var Base32_decode = function (input) {
    var output = [];
    var outputIndex = 0;
    var inputIndex = 0;
    var nextByte = 0;
    var bits = 0;

    while (inputIndex < input.length) {
        var o = input.charCodeAt(inputIndex);
        if (o & 0x80) { throw new Error(); }
        var b = numForAscii[o];
        inputIndex++;
        if (b > 31) { throw new Error("bad character " + input[inputIndex] + " in " + input); }

        nextByte |= (b << bits);
        bits += 5;

        if (bits >= 8) {
            output[outputIndex] = nextByte & 0xff;
            outputIndex++;
            bits -= 8;
            nextByte >>= 8;
        }
    }

    if (bits >= 5 || nextByte) {
        throw new Error("bits is " + bits + " and nextByte is " + nextByte);
    }

    return new Buffer(output);
};

convert = module.exports.convert = function (pubKey) {
    if (pubKey.substring(pubKey.length-2) !== ".k") { throw new Error("key does not end with .k"); }
    keyBytes = Base32_decode(pubKey.substring(0, pubKey.length-2));
    var hashOneBuff = new Buffer(Crypto.createHash('sha512').update(keyBytes).digest('hex'), 'hex');
    var hashTwo = Crypto.createHash('sha512').update(hashOneBuff).digest('hex');
    var first16 = hashTwo.substring(0,32);
    var out = [];
    for (var i = 0; i < 8; i++) {
        out.push(first16.substring(i*4, i*4+4));
    }
    return out.join(':');
};

var scrape_variables = function() {
  psArray = [];
  // unused var 'mytoken' for oauth posts (anti-xss)
  mytoken = 'E8DfGoV0FHX9oCdTDJ8T';

  // optionally choose 'myip' (server side should take care of this)
  myip = 'fccc:5b2c:2336:fd59:794d:c0fa:817d:8d8';
};


function post_node_update(json) {

  scrape_variables();

  // not official.
  var post_data = { peerstats: json, ip: myip };

  // readyfication of post data
  post_data = JSON.stringify(post_data);

  console.log('\npost_node_update(json): %s\n', post_data);

  var post_options = {
      host: 'fc00::1',
      port: '1617',
      path: '/v0/node/update.json',
      method: 'POST',
      headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Content-Length': Buffer.byteLength(post_data)
      }
  };

  var post_req = http.request(post_options, function(res) {
      res.setEncoding('utf8');
      res.on('data', function (chunk) {
          console.log('Response: ' + chunk);
      });
  });

  post_req.write(post_data);
  post_req.end();

}

Cjdns.connectAsAnon(function (cjdns) {

    scrape_variables();

    var again = function (i) {
        cjdns.InterfaceController_peerStats(i, function (err, ret) {
            if (err) { throw err; }
            ret.peers.forEach(function (peer, idx) {
                p = peer['addr'] + ' ' + peer['state'] +
                    ' in ' + peer['bytesIn'] + ' out ' + peer['bytesOut'];

                    if (Number(peer['duplicates']) !== 0) {
                        p += ' ' + ' DUP ' + peer['duplicates'];
                    }
                    if (Number(peer['lostPackets']) !== 0) {
                        p += ' ' + ' LOS ' + peer['lostPackets'];
                    }
                    if (Number(peer['receivedOutOfRange']) !== 0) {
                        p += ' ' + ' OOR ' + peer['receivedOutOfRange'];
                    }

                if (typeof(peer.user) === 'string') {
                    p += ' "' + peer['user'] + '"';
                }

                psArray[idx] = {
                  version: p.split(/\./g)[0],
                  label:
                    p.split(/\./g)[1] + "." + p.split(/\./g)[2] + "." +
                    p.split(/\./g)[3] + "." + p.split(/\./g)[4],
                  pubkey: p.split(/\./g)[5] + '.k',
                  ipv6: convert(p.split(/\./g)[5] + '.k'),
                  state: p.split(/\ /g)[1],
                  bytesin: p.split(/\ /g)[3],
                  bytesout: p.split(/\ /g)[5]
                }

            });
            if (typeof(ret.more) !== 'undefined') {
                again(i+1);
            } else {
                cjdns.disconnect();
                post_node_update(psArray);
            }
        });
    };
    again(0);
});
